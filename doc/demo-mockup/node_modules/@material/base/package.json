{
  "_args": [
    [
      {
        "raw": "@material/base",
        "scope": "@material",
        "escapedName": "@material%2fbase",
        "name": "@material/base",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "/home/federico/git/librecandy/doc/demo-mockup"
    ]
  ],
  "_from": "@material/base@latest",
  "_id": "@material/base@0.1.2",
  "_inCache": true,
  "_location": "/@material/base",
  "_nodeVersion": "7.2.1",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/base-0.1.2.tgz_1487698049341_0.8139528860338032"
  },
  "_npmUser": {
    "name": "material",
    "email": "traviskaufman+npm@google.com"
  },
  "_npmVersion": "3.10.10",
  "_phantomChildren": {},
  "_requested": {
    "raw": "@material/base",
    "scope": "@material",
    "escapedName": "@material%2fbase",
    "name": "@material/base",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/",
    "/@material/checkbox",
    "/@material/dialog",
    "/@material/drawer",
    "/@material/form-field",
    "/@material/grid-list",
    "/@material/icon-toggle",
    "/@material/menu",
    "/@material/radio",
    "/@material/ripple",
    "/@material/select",
    "/@material/snackbar",
    "/@material/textfield",
    "/@material/toolbar",
    "/material-components-web"
  ],
  "_resolved": "https://registry.npmjs.org/@material/base/-/base-0.1.2.tgz",
  "_shasum": "5cc685eeb3c56fcb13905228aec50f96e2012df7",
  "_shrinkwrap": null,
  "_spec": "@material/base",
  "_where": "/home/federico/git/librecandy/doc/demo-mockup",
  "bugs": {
    "url": "https://github.com/material-components/material-components-web/issues"
  },
  "dependencies": {},
  "description": "The set of base classes for Material Components for the web",
  "devDependencies": {},
  "directories": {},
  "dist": {
    "shasum": "5cc685eeb3c56fcb13905228aec50f96e2012df7",
    "tarball": "https://registry.npmjs.org/@material/base/-/base-0.1.2.tgz"
  },
  "homepage": "https://github.com/material-components/material-components-web#readme",
  "license": "Apache-2.0",
  "main": "index.js",
  "maintainers": [
    {
      "name": "material",
      "email": "traviskaufman+npm@google.com"
    }
  ],
  "name": "@material/base",
  "optionalDependencies": {},
  "readme": "# mdc-base\n\nMDC base contains core foundation and component classes that serve as the base classes for all of MDC-Web's foundation classes and components (respectively).\n\nMost of the time, you shouldn't need to depend on `mdc-base` directly. It is useful however if you'd like to write custom components that follow MDC-Web's pattern and elegantly integrate with the MDC-Web ecosystem.\n\n## Installation\n\nFirst install the module:\n\n```\nnpm install --save @material/base\n```\n\nThen include it in your code in one of the following ways:\n\n#### ES2015+\n\n```javascript\nimport {MDCComponent, MDCFoundation} from 'mdc-base';\n```\n#### CommonJS\n\n```javascript\nconst MDCComponent = require('mdc-base').MDCComponent;\nconst MDCFoundation = require('mdc-base').MDCFoundation;\n```\n\n#### AMD\n\n```javascript\nrequire(['path/to/mdc-base'], function(mdcBase) {\n  const MDCComponent = mdcBase.MDCComponent;\n  const MDCFoundation = mdcBase.MDCFoundation;\n});\n```\n\n#### Vanilla\n\n```javascript\nconst MDCComponent = mdc.base.MDCComponent;\nconst MDCFoundation = mdc.base.MDCFoundation;\n```\n\n## Usage\n\nmdc-base exposes two classes: `MDCComponent` (the default export) which all components extend from, and `MDCFoundation`, which all foundation classes extend from. To learn more about foundation classes vs. components, check out our [developer guide](https://github.com/material-components/material-components-web/blob/master/docs/DEVELOPER.md) (_WIP_).\n\n### MDCFoundation\n\nMDCFoundation provides the basic mechanisms for implementing a foundation classes. Subclasses are expected to:\n\n- Provide implementations of the proper static getters where necessary.\n- Provide `init()` and `destroy()` lifecycle methods\n\n```javascript\nimport {MDCFoundation} from 'mdc-base';\n\nexport default class MyFoundation extends MDCFoundation {\n  static get cssClasses() {\n    return {\n      ROOT: 'my-component',\n      MESSAGE: 'my-component__message',\n      BUTTON: 'my-component__button',\n      TOGGLED: 'my-component--toggled'\n    };\n  }\n\n  static get defaultAdapter() {\n    return {\n      toggleClass: (/* className: string */) => {},\n      registerBtnClickHandler: (/* handler: Function */) => {},\n      deregisterBtnClickHandler: (/* handler: Function */) => {}\n    };\n  }\n\n  constructor(adapter) {\n    super(Object.assign(MyFoundation.defaultAdapter, adapter));\n    const {TOGGLED} = MyFoundation.cssClasses;\n    this.clickHandler_ = () => this.adapter_.toggleClass(TOGGLED);\n  }\n\n  init() {\n    this.adapter_.registerBtnClickHandler(this.clickHandler_);\n  }\n\n  destroy() {\n    this.adapter_.deregisterBtnClickHandler(this.clickHandler_);\n  }\n}\n```\n\n#### Static Getters\n\nThe static getters specify constants that can be used within the foundation class, its component, and by 3rd-party code. _It's important to remember to always put constants into these getters_. This will ensure your component can interop in as many environments as possible, including those where CSS classes need to be overwritten by the host library (e.g., Closure Stylesheets), or strings need to be modified (for i18n, for example).\n\nNote that you do not have to explicitly provide getters for constants if your component has none.\n\nThe getters which should be provided are specified below:\n\n| getter | description |\n| --- | --- |\n| cssClasses | returns an object where each key identifies a css class that some code will rely on. |\n| strings | returns an object where each key identifies a string constant, e.g. `ARIA_ROLE` |\n| numbers | returns an object where each key identifies a numeric constant, e.g. `TRANSITION_DELAY_MS` |\n| defaultAdapter | returns an object specifying the shape of the adapter. Can be used as sensible defaults for an adapter as well as a way to specify your adapter's \"schema\" |\n\n#### Lifecycle Methods\n\nEach foundation class has two lifecycle methods: `init()` and `destroy()`, which are described below:\n\n| method | time of invocation | use case |\n| --- | --- | --- |\n| init() | called by a host class when a component is ready to be initialized | add event listeners, query for info via adapters, etc. |\n| destroy() | called by a host class when a component is no longer in use | remove event listeners, reset any transient state, etc. |\n\n### MDCComponent\n\nMDCComponent provides the basic mechanisms for implementing component classes.\n\n```javascript\nimport MyComponentFoundation from './foundation';\n\nexport class MyComponent extends MDCComponent {\n  static attachTo(root) {\n    return new MyComponent(root);\n  }\n\n  getDefaultFoundation() {\n    const btn = this.root.querySelector(`.${MyComponentFoundation.cssClasses.BUTTON}`);\n    return new MyComponentFoundation({\n      toggleClass: className => {\n        if (this.root.classList.contains(className)) {\n          this.root.classList.remove(className);\n          return;\n        }\n        this.root.classList.add(className);\n      },\n      registerBtnClickHandler: handler => btn.addEventListener('click', handler),\n      deregisterBtnClickHandler: handler => btn.removeEventListener('click', handler)\n    });\n  }\n}\n```\n\n#### Properties\n\n`MDCComponent` provides the following \"private\" properties to subclasses:\n\n| property | description |\n| --- | --- |\n| `root_` | The root element passed into the constructor as the first argument. |\n| `foundation_` | The foundation class for this component. This is either passed in as an optional second argument to the constructor, or assigned the result of calling `getDefaultFoundation()` |\n\n#### Methods\n\n`MDCComponent` provides the following methods to subclasses:\n\n| method | description |\n| --- | --- |\n| `initialize(...args)` | Called after the root element is attached to the component, but _before_ the foundation is instantiated. Any positional arguments passed to the component constructor after the root element, along with the optional foundation 2nd argument, will be provided to this method. This is a good place to do any setup work normally done within a constructor function. |\n| `getDefaultFoundation()` | Returns an instance of a foundation class properly configured for the component. Called when no foundation instance is given within the constructor. Subclasses **must** implement this method. |\n| `initialSyncWithDOM()` | Called within the constructor. Subclasses may override this method if they wish to perform initial synchronization of state with the host DOM element. For example, a slider may want to check if its host element contains a pre-set value, and adjust its internal state accordingly. Note that the same caveats apply to this method as to foundation class lifecycle methods. Defaults to a no-op. |\n| `destroy()` | Subclasses may override this method if they wish to perform any additional cleanup work when a component is destroyed. For example, a component may want to deregister a window resize listener. |\n| `listen(type: string, handler: EventListener)` | Adds an event listener to the component's root node for the given `type`. Note that this is simply a proxy to `this.root_.addEventListener`. |\n| `unlisten(type: string, handler: EventListener)` | Removes an event listener from the component's root node. Note that this is simply a proxy to `this.root_.removeEventListener`. |\n| `emit(type: string, data: Object)` | Dispatches a custom event of type `type` with detail `data` from the component's root node. This is the preferred way of dispatching events within our vanilla components. |\n\n#### Static Methods\n\nIn addition to methods inherited, subclasses should implement the following two static methods within their code:\n\n| method | description |\n| --- | --- |\n| `attachTo(root) => <ComponentClass>` | Subclasses must implement this as a convenience method to instantiate and return an instance of the class using the root element provided. This will be used within `mdc-auto-init`, and in the future its presence may be enforced via a custom lint rule.|\n\n#### Foundation Lifecycle handling\n\n`MDCComponent` calls its foundation's `init()` function within its _constructor_, and its foundation's `destroy()` function within its own _destroy()_ function. Therefore it's important to remember to _always call super() when overriding destroy()_. Not doing so can lead to leaked resources.\n\n#### Initialization and constructor parameters\n\nIf you need to pass in additional parameters into a component's constructor, you can make use of the\n`initialize` method, as shown above. An example of this is passing in a child component as a\ndependency.\n\n```js\nclass MyComponent extends MDCComponent {\n  initialize(childComponent = null) {\n    this.child_ = childComponent ?\n      childComponent : new ChildComponent(this.root_.querySelector('.child'));\n  }\n\n  getDefaultFoundation() {\n    return new MyComponentFoundation({\n      doSomethingWithChildComponent: () => this.child_.doSomething(),\n      // ...\n    });\n  }\n}\n```\n\nYou could call this code like so:\n\n```js\nconst childComponent = new ChildComponent(document.querySelector('.some-child'));\nconst myComponent = new MyComponent(\n  document.querySelector('.my-component'), /* foundation */ undefined, childComponent\n);\n// use myComponent\n```\n\n> NOTE: You could also pass in an initialized foundation if you wish. The example above simply\n> showcases how you could pass in initialization arguments without instantiating a foundation.\n\n#### Best Practice: Keep your adapters simple\n\nIf you find your adapters getting too complex, you should consider refactoring the complex parts out into their own implementations.\n\n```javascript\nimport MyComponentFoundation from './foundation';\nimport {toggleClass} from './util';\n\nclass MyComponent {\n  // ...\n  getDefaultFoundation() {\n    return new MyComponentFoundation({\n      toggleClass: className => util.toggleClass(this.root_, className),\n      // ...\n    });\n  }\n}\n```\n\nWhere `./util` could look like:\n\n```javascript\nexport function toggleClass(element, className) {\n  if (root.classList.contains(className)) {\n    root.classList.remove(className);\n    return;\n  }\n  root.classList.add(className);\n}\n```\n\nThis not only reduces the complexity of your component class, but allows for the functionality of complex adapters to be adequately tested:\n\n```javascript\ntest('toggleClass() removes a class when present on an element', t => {\n  const root = document.createElement('div');\n  root.classList.add('foo');\n\n  util.toggleClass(root, 'foo');\n\n  t.false(root.classList.contains('foo'));\n  t.end();\n});\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/material-components/material-components-web.git"
  },
  "scripts": {},
  "version": "0.1.2"
}
